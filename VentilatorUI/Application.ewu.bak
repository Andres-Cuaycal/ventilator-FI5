$version 9.30

// This is the root component of the entire GUI application.
$rect <30,40,230,80>
$output false
class Application : Core::Root
{
  $rect <500,0,700,40>
  inherited property Bounds = <0,0,480,272>;

  // To do:
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widgets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <0,290,780,490>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,480,272>;
    preset Color = #000000FF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <190,110,300,140>;
    preset String = "Hello!";
    preset Font = Application::Font;
  }

  $rect <20,20,160,60>
  object Application::DataplotterWin32 Dataplotter
  {
    preset Bounds = <0,0,480,80>;
  }

  $rect <520,70,720,110>
  object Application::DataSource0 DataSource0;

  $rect <520,150,720,190>
  object Application::DataSource2 DataSource2;

  $rect <520,110,720,150>
  object Application::DataSource1 DataSource1;
}

// This is a font resource.
$rect <230,130,430,170>
$output false
resource Resources::Font Font
{
  attr fontname FontName = Arial;
  attr fontheight Height = 32;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <20,130,220,170>
$variant WIN32,true
vclass ApplicationVariantWin32 : Application::Application
{
  $rect <870,30,1150,70>
  inherited property Bounds = <0,0,800,640>;

  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <0,0,800,640>;
  }

  $rect <20,20,160,60>
  inherited object Text
  {
    preset Bounds = <1130,180,1240,210>;
  }

  $rect <20,20,160,60>
  object Application::MenubarWin32 Menubar
  {
    preset Bounds = <0,480,800,640>;
  }

  $rect <20,20,160,60>
  object Application::DataplotterWin32 DataplotterInspPress
  {
    preset Bounds = <0,0,800,160>;
    preset ColorProp = #F9FF0AFF;
    preset NameProp = "Insp. press.(mBar)";
    preset DataProvider = DataSource0;
  }

  $rect <20,20,160,60>
  object Application::DataplotterWin32 DataplotterVTidal
  {
    preset Bounds = <0,160,800,320>;
    preset ColorProp = #40FF0AFF;
    preset NameProp = "V_tidal(mL)";
    preset DataProvider = DataSource1;
  }

  $rect <20,20,160,60>
  object Application::DataplotterWin32 DataplotterMve
  {
    preset Bounds = <0,320,800,480>;
    preset ColorProp = #0AFFF5FF;
    preset NameProp = "MVe (slpm)";
    preset DataProvider = DataSource2;
  }
}

$rect <20,170,220,210>
$output false
class DataplotterWin32 : Core::Group
{
  $rect <0,180,200,220>
  inherited property Bounds = <0,0,800,160>;

  $rect <20,20,160,60>
  object Charts::Graph Graph
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,640,160>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <640,0,800,160>;
    preset Color = #040404FF;
  }

  $rect <20,20,160,60>
  object Views::Text Name
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <640,0,800,30>;
    preset String = "Name";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object Views::Text CurrValue
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <640,40,800,80>;
    preset String = "00";
    preset Font = Resources::FontExtraLarge;
  }

  $rect <20,20,160,60>
  object Views::Text MeanText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <640,90,720,120>;
    preset String = "Mean";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object Views::Text MaxText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <640,120,720,150>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignHorzLeft, AlignVertCenter];
    preset String = "Max";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object Views::Text MeanValue
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <720,90,800,120>;
    preset String = "00.0";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object Views::Text MaxValue
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <720,120,800,150>;
    preset String = "00.0";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,800,160>;
  }

  $rect <20,20,160,60>
  object Charts::Graph Graph1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <210,260,622,328>;
    preset Buffered = true;
    preset Coordinates = CoordList;
    preset LineWidth = 3.0;
    preset DotColor = #FFFFFFFF;
    preset DotWidth = 3.0;
    preset PixelPerUnit = <5,5>;
    preset GridDistance = <10,10>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <620,260,688,328>;
    preset Color = #040404FF;
  }

  $rect <20,20,160,60>
  object Views::Text Name1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <620,260,690,280>;
    preset String = "Name";
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text CurrValue1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <620,280,688,300>;
    preset String = "00";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Text MeanText1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <620,302,654,312>;
    preset String = "Mean";
    preset Font = Application::FontXS;
  }

  $rect <20,20,160,60>
  object Views::Text MaxText1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <620,314,654,324>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignHorzLeft, AlignVertCenter];
    preset String = "Max";
    preset Font = Application::FontXS;
  }

  $rect <20,20,160,60>
  object Views::Text MeanValue1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <654,302,688,312>;
    preset String = "00.0";
    preset Font = Application::FontXS;
  }

  $rect <20,20,160,60>
  object Views::Text MaxValue1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <654,314,688,324>;
    preset String = "00.0";
    preset Font = Application::FontXS;
  }

  $rect <800,210,1000,250>
  property color ColorProp = #FFFFFFFF;

  $rect <800,260,1000,300>
  onset ColorProp
  {
    // The value doesn't change - nothing to do.
    if ( pure ColorProp == value )
      return;

    // Remember the property's new value.
    pure ColorProp = value;
    pure BeamColor = value;

    MaxValue.Color   = value;
    MeanValue.Color  = value;
    MaxText.Color    = value;
    MeanText.Color   = value;
    CurrValue.Color  = value;
    Name.Color       = value;
    Graph.DotColor   = value;
    Graph.LineColor  = value;

  }

  $rect <810,120,1010,160>
  property string NameProp = "Name";

  $rect <810,160,1010,200>
  onset NameProp
  {
    // The value doesn't change - nothing to do.
    if ( pure NameProp == value )
      return;

    // Remember the property's new value.
    pure NameProp = value;

    Name.String = value;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <210,260,690,328>;
  }

  // The property 'Speed' stores the speed of the beam in milliseconds per division. \
  // Depending on the speed, the necessary number of samples are displayed.
  $rect <60,500,260,540>
  property int32 Speed = 100;

  // The onset method for the property 'Speed' changes the speed of the beam in the \
  // range from 1 to 1000.
  $rect <270,390,470,430>
  onset Speed
  {
    /* limit the milliseconds per division to a range from 1 to 1000 */
    if ( value < 1 )
      value = 1;

    if ( value > 1000 )
      value = 1000;

    /* assign the value */
    pure Speed = value;

    /* and inform the data provider */
    if ( DataProvider != null )
      DataProvider.Speed = value;
  }

  // The property 'RefreshRate' stores the number of milliseconds between the single \
  // display updates. Depending on the RefreshRate, the necessary number of samples \
  // are displayed.
  $rect <490,350,690,390>
  property int32 RefreshRate = 50;

  // The onset method for the property 'RefreshRate' changes the update interval \
  // in the range from 10 to 1000 ms.
  $rect <260,240,460,280>
  onset RefreshRate
  {
    /* limit the refresh rate to a range from 10 to 1000 */
    if ( value < 10 )
      value = 10;

    if ( value > 1000 )
      value = 1000;

    /* assign the value and set the update timer to the new period */
    pure RefreshRate = value;
    UpdateTimer.Period = value;
  }

  // The property 'ScreenWiper' stores the width of the screen wiper in the range \
  // from 0 to 100 (percent). The screen wiper clears the area right of the current \
  // beam position with a soft fade our effect.
  $rect <480,180,680,220>
  property int32 ScreenWiper = 20;

  // The onset method for the property 'ScreenWiper' changes the width of the screen \
  // wiper in the range from 0 (off) to 100 percent.
  $rect <490,230,690,270>
  onset ScreenWiper
  {
    /* limit size of screen wiper to a range from 0 to 100 */
    if ( value < 0 )
      value = 0;

    if ( value > 100 )
      value = 100;

    /* assign the value */
    pure ScreenWiper = value;
  }

  // The property 'BeamColor' stores the color value of the simulated beam.
  $rect <1020,60,1220,100>
  property color BeamColor = #00FF06FF;

  // The property 'BeamGlow' stores the width of the simulated beam point in the \
  // range from 0 to 3.
  $rect <760,360,960,400>
  property int32 BeamGlow = 1;

  // The onset method for the property 'BeamGlow' changes the size of the simulated \
  // beam point.
  $rect <760,400,960,440>
  onset BeamGlow
  {
    /* limit size of beam glow to a range from 0 to 3 */
    if ( value < 0 )
      value = 0;

    if ( value > 3 )
      value = 3;

    pure BeamGlow = value;
  }

  // The property 'Gain' stores the scaling factor in vertical direction in the range \
  // from 0 to 1000 (percent).
  $rect <280,300,480,340>
  property int32 Gain = 100;

  // The onset method for the property 'Gain' changes the vertical scaling factor \
  // in the range from 0 to 1000 percent.
  $rect <270,340,470,380>
  onset Gain
  {
    /* limit size of gain to a range from 10 to 1000 */
    if ( value < 0 )
      value = 0;

    if ( value > 1000 )
      value = 1000;

    /* assign the value */
    pure Gain = value;
  }

  // The 'Image' view contains the prepared data bitmap of the oscilloscope.
  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <310,390,358,438>;
  }

  // The variable 'Canvas' stores the internal bitmap used to prepare all drawing \
  // operations.
  $rect <490,290,690,330>
  var Graphics::Canvas Canvas = null;

  // The variable 'Clipping' contains the clipping area used for all drawing operations \
  // within the Canvas.
  $rect <50,390,250,430>
  var rect Clipping = <0,0,0,0>;

  // The variable 'BeamPosition' stores the current position of the simulated beam \
  // in horizontal and vertical direction.
  $rect <70,550,270,590>
  var point BeamPosition = <0,0>;

  // The 'UpdateTimer' object is responsible to trigger the update of the scope.
  $rect <790,310,990,350>
  object Core::Timer UpdateTimer
  {
    preset OnTrigger = DrawGraph;
    preset Period = 100;
    preset Enabled = true;
  }

  // The method 'DrawBeamLine' is called to draw the beam at the given horizontal \
  // position 'aX' from the vertical start position 'aY1' to the end position 'aY2'.
  $rect <40,440,240,480>
  method void DrawBeamLine( arg int32 aX, arg int32 aY1, arg int32 aY2 )
  {
    var int32 y1;
    var int32 y2;
    var rect  r;
    var color c;

    /* just to be sure... */
    if ( Canvas == null )
      return;

    /* sort the give y values */
    if ( aY1 < aY2 )
    {
      y1 = aY1;
      y2 = aY2;
    }  
    else
    {
      y1 = aY2;
      y2 = aY1;
    }  

    /* draw the outer glow */
    if ( BeamGlow > 2 )
    {
      c = color( BeamColor.red, BeamColor.green, BeamColor.blue, 0x10 );
      r = rect( aX - 3, y1 - 2, aX + 4, y2 + 3 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );

      r = rect( aX - 2, y1 - 3, aX + 3, y2 + 4 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );
    }

    /* draw the middle glow */
    if ( BeamGlow > 1 )
    {
      c = color( BeamColor.red, BeamColor.green, BeamColor.blue, 0x20 );
      r = rect( aX - 2, y1 - 1, aX + 3, y2 + 2 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );

      r = rect( aX - 1, y1 - 2, aX + 2, y2 + 3 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );
    }  

    /* draw the inner glow */
    if ( BeamGlow > 0 )
    {
      c = color( BeamColor.red, BeamColor.green, BeamColor.blue, 0x40 );
      r = rect( aX - 1, y1    , aX + 2, y2 + 1 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );

      r = rect( aX    , y1 - 1, aX + 1, y2 + 2 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );
    }  

    /* draw the center point of the beam */
    c = color( BeamColor.red, BeamColor.green, BeamColor.blue, 0x80 );
    r = rect( aX    , y1    , aX + 1, y2 + 1 );
    Canvas.FillRectangle( Clipping, r, c, c, c, c, true );

  }

  // The 'UpdateSlot' is responsible to draw the next sequence of data samples. The \
  // number of samples depends on the current settings of 'RefreshRate' and the 'MillisecPerDiv'.
  $rect <280,440,480,480>
  slot UpdateSlot
  {
    /* Remark: In order to simplifiy this demo application, we assume, that for 
       each horizontal position one samples is read from the underlying measurement 
       equipment and that each sample is in the range from -100 ... + 100 */

    var int32 noOfSamples;
    var int32 x;
    var int32 y1;
    var int32 y2;
    var rect r;
    var rect invalidateRect;
    var int32 wiper;

    /* just to be sure... */
    if ( Canvas == null )
      return;

    /* calculate size of screen wiper */
    wiper = ScreenWiper * Bounds.w / 100;

    /* first we have to decide, whether a full screen update is necessary or just
       part of the screen are redrawn */

    if ( RefreshRate / Speed >= 10 )
    {
      /* we have to make a full screen update */
      noOfSamples = Bounds.w;

      /* clear complete area */
      r = rect( 0, 0, Bounds.w, Bounds.h );
      Canvas.FillRectangle( r, r, #000000FF, #000000FF, #000000FF, #000000FF, false );

      /* complete area needs to be updated at the end */
      invalidateRect = rect( 0, 0, Bounds.w, Bounds.h );
    }
    else
    {
      /* only part of the screen will be drawn */
      noOfSamples = ( Bounds.w * RefreshRate ) / ( Speed * 10 );

      /* here we make a small simplification: at least one sample is drawn */
      if ( noOfSamples == 0 )
        noOfSamples = 1;

      /* get current beam position */
      x = BeamPosition.x + 1;

      /* clear area right of the beam position */
      r = rect( x + 2, 0, x + 5 + noOfSamples, Bounds.h );
      Canvas.FillRectangle( r, r, #000000FF, #000000FF, #000000FF, #000000FF, false );

      /* calculate the necessary update area */
      invalidateRect = rect( x - 4, 0, x + 4 + noOfSamples, Bounds.h );

      /* check for wrap around */
      if ( x + noOfSamples > Bounds.w )
      {
        /* clear area at the left side */
        r = rect( 0, 0, x + 5 + noOfSamples - Bounds.w, Bounds.h );
        Canvas.FillRectangle( r, r, #000000FF, #000000FF, #000000FF, #000000FF, false );
        
        /* due to wrap around complete area needs to be updated at the end */
        invalidateRect = rect( 0, 0, Bounds.w, Bounds.h );
      }

      /* blend area right of the beam position if screen wiper is active */
      if ( wiper > 0 )
      {
        /* blend area right of the beam position */
        r = rect( x + 2 + noOfSamples, 0, x + wiper + noOfSamples, Bounds.h );
        Canvas.FillRectangle( r, r, #0000001F, #0000001F, #0000001F, #0000001F, true );
      
        /* calculate the necessary update area */
        invalidateRect = rect( x - 4, 0, x + 4 + wiper + noOfSamples, Bounds.h );

        /* check for wrap around of wiper */
        if ( x + wiper + noOfSamples > Bounds.w )
        {
          /* blend area at the left side */
          r = rect( 0, 0, x + wiper + noOfSamples - Bounds.w, Bounds.h );
          Canvas.FillRectangle( r, r, #0000001F, #0000001F, #0000001F, #0000001F, true );
      
          /* due to wrap around complete area needs to be updated at the end */
          invalidateRect = rect( 0, 0, Bounds.w, Bounds.h );
        }
      }
    }

    /* now, all samples are drawn... */
    while ( noOfSamples > 0 )
    {
      /* get next beam position */
      x = BeamPosition.x + 1;
      if ( x >= Bounds.w )
        x = 0;
      
      /* calculate start and end value in vertical direction */
      y1 = BeamPosition.y;
      y2 = Bounds.h / 2 - GetSampleData( x ) * Bounds.h / 200;

      /* adjust start position for one pixel to avoid double drawing */
      if ( y2 > y1 )
        y1 = y1 + 1;
      if ( y2 < y1 )
        y1 = y1 - 1;

      /* draw the beam from the last sample value to the new sample value */
      DrawBeamLine( x, y1, y2 );

      /* store the current beam position */
      BeamPosition.x = x;
      BeamPosition.y = y2;

      /* next one... */
      noOfSamples = noOfSamples - 1;
    }

    /* finally, we set the calculated area as invalid area of the image object
       to force the redrawing */
    InvalidateArea( invalidateRect );

  }

  // This function returns the data of the given index from an simulated measurement \
  // equipment. 
  $rect <500,410,700,450>
  method int32 GetSampleData( arg int32 aIndex )
  {
    var int32 value;

    if ( DataProvider == null )
      value = aIndex % 100 - 50;

    else
      value = DataProvider.GetSampleData( aIndex );
      
    /* modify the value with the gain */
    value = value * Gain / 100;

    if ( value < -100 )
      value = -100;
    if ( value > 100 )
      value = 100;

    return value;

  }

  $rect <1030,10,1230,50>
  slot DrawGraph
  {
    //var int32 randomNumber = math_rand( 0, 10 );

    if (DataProvider == null)
        return;
    var float currVal = float(DataProvider.GetSampleData( index ));
    // compute max
    if (currVal > max) {
        max = currVal;
        MaxValue.String = string(max, 0, 1);
    }
    // get mean
    if (index!=0) {
        sum = sum + currVal;
        MeanValue.String = string(sum / float(index),0,1);
    }
    CurrValue.String = string(currVal, 0, 1); // 2 decimal values
    var float vOffset = Graph.Bounds.h / Graph.PixelPerUnit.y;
    var float hOffset = Graph.Bounds.w / Graph.PixelPerUnit.x;
    var float vScalingFactor = float(Graph.PixelPerUnit.y) / float(Graph.Bounds.h);
    CoordList.AddCoord( index,  vOffset/2.0 - vScalingFactor * float(currVal));
    Graph.Coordinates = CoordList;
    // to do loop graph and reset statistics
    if(float(index)>=hOffset) {
        index= 0;
        CoordList.ClearList();
        sum = 0;
    }
    index = index + 1;
    // Invoke UpdateViewState
    this.InvalidateViewState();
  }

  $rect <810,80,1010,120>
  var int32 index = 0;

  $rect <260,190,440,230>
  object Charts::CoordList CoordList
  {
    preset MaxNoOfItems = 1000;
  }

  $rect <1040,110,1240,150>
  var float mean;

  $rect <1040,160,1240,200>
  var float max = -10000.0;

  $rect <1250,520,1450,560>
  var float sum = -10000.0;

  $rect <60,300,260,340>
  property Application::DataSource DataProvider = null;

  $rect <60,340,260,380>
  onset DataProvider
  {
    pure DataProvider = value;

  }
}

$rect <20,210,220,250>
$output false
class MenubarWin32 : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,800,160>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,0,100,160>;
    preset Label = "Menu";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <100,0,200,160>;
    preset Label = "Settings";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <200,0,300,160>;
    preset Label = "Expr. Pause";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <300,0,400,160>;
    preset Label = "Insp. Pause";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <400,0,500,160>;
    preset Label = "Set Assisted";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton5
  {
    preset Bounds = <500,0,600,160>;
    preset Label = "Caption";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton6
  {
    preset Bounds = <600,0,800,160>;
    preset Label = "StartAutomatic";
    preset Appearance = WidgetSet::PushButton_Medium;
  }
}

// This is a font resource.
$rect <790,130,990,170>
$output false
resource Resources::Font FontXS
{
  attr fontname FontName = Arial;
  attr fontheight Height = 10;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <580,130,780,170>
$variant STM32F746,true
vclass ApplicationVariantSTM32 : Application::Application
{
  $rect <870,30,1150,70>
  inherited property Bounds = <0,0,480,272>;

  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <0,0,480,272>;
  }

  $rect <20,20,160,60>
  inherited object Text
  {
    preset Bounds = <1130,180,1240,210>;
  }

  $rect <20,20,160,60>
  inherited object Dataplotter
  {
    preset Bounds = <20,310,500,390>;
  }

  $rect <20,20,160,60>
  object Application::MenubarSTM32 Menubar
  {
    preset Bounds = <0,204,480,272>;
  }

  $rect <20,20,160,60>
  object Application::DataplotterSTM32 DataplotterInspPress
  {
    preset Bounds = <0,0,480,68>;
    preset ColorProp = #F9FF0AFF;
    preset NameProp = "P_ins(mBar)";
    preset DataProvider = DataSource0;
  }

  $rect <20,20,160,60>
  object Application::DataplotterSTM32 DataplotterVTidal
  {
    preset Bounds = <0,68,480,136>;
    preset ColorProp = #40FF0AFF;
    preset NameProp = "V_tidal(mL)";
    preset DataProvider = DataSource1;
  }

  $rect <20,20,160,60>
  object Application::DataplotterSTM32 DataplotterMve
  {
    preset Bounds = <0,136,480,204>;
    preset ColorProp = #0AFFF5FF;
    preset NameProp = "MVe (slpm)";
    preset DataProvider = DataSource2;
  }
}

$rect <580,170,780,210>
$output false
class DataplotterSTM32 : Core::Group
{
  $rect <0,180,200,220>
  inherited property Bounds = <0,0,480,68>;

  $rect <0,280,200,320>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <-10,230,190,270>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
    //Graph.CoordOrigin = point (index, Graph.Bounds.h-68);

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Charts::Graph Graph
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,412,68>;
    preset Buffered = true;
    preset Coordinates = CoordList;
    preset LineWidth = 3.0;
    preset DotColor = #FFFFFFFF;
    preset DotWidth = 3.0;
    preset PixelPerUnit = <5,5>;
    preset GridDistance = <10,10>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <410,0,478,68>;
    preset Color = #040404FF;
  }

  $rect <20,20,160,60>
  object Views::Text Name
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <410,0,480,20>;
    preset String = "Name";
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text CurrValue
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <410,20,478,40>;
    preset String = "00";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Text MeanText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <410,42,444,52>;
    preset String = "Mean";
    preset Font = Application::FontXS;
  }

  $rect <20,20,160,60>
  object Views::Text MaxText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <410,54,444,64>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignHorzLeft, AlignVertCenter];
    preset String = "Max";
    preset Font = Application::FontXS;
  }

  $rect <20,20,160,60>
  object Views::Text MeanValue
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <444,42,478,52>;
    preset String = "00.0";
    preset Font = Application::FontXS;
  }

  $rect <20,20,160,60>
  object Views::Text MaxValue
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <444,54,478,64>;
    preset String = "00.0";
    preset Font = Application::FontXS;
  }

  $rect <830,80,1030,120>
  property color ColorProp = #FFFFFFFF;

  $rect <830,120,1030,160>
  onset ColorProp
  {
    // The value doesn't change - nothing to do.
    if ( pure ColorProp == value )
      return;

    // Remember the property's new value.
    pure ColorProp = value;
    pure BeamColor = value;

    MaxValue.Color   = value;
    MeanValue.Color  = value;
    MaxText.Color    = value;
    MeanText.Color   = value;
    CurrValue.Color  = value;
    Name.Color       = value;
    Graph.DotColor   = value;
    Graph.LineColor  = value;

  }

  $rect <840,0,1040,40>
  property string NameProp = "Name";

  $rect <840,40,1040,80>
  onset NameProp
  {
    // The value doesn't change - nothing to do.
    if ( pure NameProp == value )
      return;

    // Remember the property's new value.
    pure NameProp = value;

    Name.String = value;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,480,68>;
  }

  // The property 'DataProvider' stores the source for getting the data to display.
  $rect <610,0,810,40>
  property Application::DataSource DataProvider = null;

  // The onset method for the property 'DataProvider' updates the data provider with \
  // the current settings.
  $rect <610,40,810,80>
  onset DataProvider
  {
    pure DataProvider = value;

  }

  // The property 'Speed' stores the speed of the beam in milliseconds per division. \
  // Depending on the speed, the necessary number of samples are displayed.
  $rect <270,390,470,430>
  property int32 Speed = 100;

  // The onset method for the property 'Speed' changes the speed of the beam in the \
  // range from 1 to 1000.
  $rect <0,340,200,380>
  onset Speed
  {
    /* limit the milliseconds per division to a range from 1 to 1000 */
    if ( value < 1 )
      value = 1;

    if ( value > 1000 )
      value = 1000;

    /* assign the value */
    pure Speed = value;

    /* and inform the data provider */
    if ( DataProvider != null )
      DataProvider.Speed = value;
  }

  // The property 'RefreshRate' stores the number of milliseconds between the single \
  // display updates. Depending on the RefreshRate, the necessary number of samples \
  // are displayed.
  $rect <500,120,700,160>
  property int32 RefreshRate = 50;

  // The onset method for the property 'RefreshRate' changes the update interval \
  // in the range from 10 to 1000 ms.
  $rect <500,160,700,200>
  onset RefreshRate
  {
    /* limit the refresh rate to a range from 10 to 1000 */
    if ( value < 10 )
      value = 10;

    if ( value > 1000 )
      value = 1000;

    /* assign the value and set the update timer to the new period */
    pure RefreshRate = value;
    UpdateTimer.Period = value;
  }

  // The property 'ScreenWiper' stores the width of the screen wiper in the range \
  // from 0 to 100 (percent). The screen wiper clears the area right of the current \
  // beam position with a soft fade our effect.
  $rect <290,120,490,160>
  property int32 ScreenWiper = 20;

  // The onset method for the property 'ScreenWiper' changes the width of the screen \
  // wiper in the range from 0 (off) to 100 percent.
  $rect <290,160,490,200>
  onset ScreenWiper
  {
    /* limit size of screen wiper to a range from 0 to 100 */
    if ( value < 0 )
      value = 0;

    if ( value > 100 )
      value = 100;

    /* assign the value */
    pure ScreenWiper = value;
  }

  // The property 'BeamColor' stores the color value of the simulated beam.
  $rect <1050,80,1250,120>
  property color BeamColor = #00FF06FF;

  // The property 'BeamGlow' stores the width of the simulated beam point in the \
  // range from 0 to 3.
  $rect <510,310,710,350>
  property int32 BeamGlow = 1;

  // The onset method for the property 'BeamGlow' changes the size of the simulated \
  // beam point.
  $rect <510,350,710,390>
  onset BeamGlow
  {
    /* limit size of beam glow to a range from 0 to 3 */
    if ( value < 0 )
      value = 0;

    if ( value > 3 )
      value = 3;

    pure BeamGlow = value;
  }

  // The property 'Gain' stores the scaling factor in vertical direction in the range \
  // from 0 to 1000 (percent).
  $rect <500,200,700,240>
  property int32 Gain = 100;

  // The onset method for the property 'Gain' changes the vertical scaling factor \
  // in the range from 0 to 1000 percent.
  $rect <490,250,690,290>
  onset Gain
  {
    /* limit size of gain to a range from 10 to 1000 */
    if ( value < 0 )
      value = 0;

    if ( value > 1000 )
      value = 1000;

    /* assign the value */
    pure Gain = value;
  }

  // The 'Image' view contains the prepared data bitmap of the oscilloscope.
  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <100,130,148,178>;
  }

  // The variable 'Canvas' stores the internal bitmap used to prepare all drawing \
  // operations.
  $rect <270,210,470,250>
  var Graphics::Canvas Canvas = null;

  // The variable 'Clipping' contains the clipping area used for all drawing operations \
  // within the Canvas.
  $rect <270,260,470,300>
  var rect Clipping = <0,0,0,0>;

  // The variable 'BeamPosition' stores the current position of the simulated beam \
  // in horizontal and vertical direction.
  $rect <250,440,450,480>
  var point BeamPosition = <0,0>;

  // The 'UpdateTimer' object is responsible to trigger the update of the scope.
  $rect <830,170,1030,210>
  object Core::Timer UpdateTimer
  {
    preset OnTrigger = DrawGraph;
    preset Period = 100;
    preset Enabled = true;
  }

  // The method 'DrawBeamLine' is called to draw the beam at the given horizontal \
  // position 'aX' from the vertical start position 'aY1' to the end position 'aY2'.
  $rect <-10,400,190,440>
  method void DrawBeamLine( arg int32 aX, arg int32 aY1, arg int32 aY2 )
  {
    var int32 y1;
    var int32 y2;
    var rect  r;
    var color c;

    /* just to be sure... */
    if ( Canvas == null )
      return;

    /* sort the give y values */
    if ( aY1 < aY2 )
    {
      y1 = aY1;
      y2 = aY2;
    }  
    else
    {
      y1 = aY2;
      y2 = aY1;
    }  

    /* draw the outer glow */
    if ( BeamGlow > 2 )
    {
      c = color( BeamColor.red, BeamColor.green, BeamColor.blue, 0x10 );
      r = rect( aX - 3, y1 - 2, aX + 4, y2 + 3 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );

      r = rect( aX - 2, y1 - 3, aX + 3, y2 + 4 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );
    }

    /* draw the middle glow */
    if ( BeamGlow > 1 )
    {
      c = color( BeamColor.red, BeamColor.green, BeamColor.blue, 0x20 );
      r = rect( aX - 2, y1 - 1, aX + 3, y2 + 2 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );

      r = rect( aX - 1, y1 - 2, aX + 2, y2 + 3 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );
    }  

    /* draw the inner glow */
    if ( BeamGlow > 0 )
    {
      c = color( BeamColor.red, BeamColor.green, BeamColor.blue, 0x40 );
      r = rect( aX - 1, y1    , aX + 2, y2 + 1 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );

      r = rect( aX    , y1 - 1, aX + 1, y2 + 2 );
      Canvas.FillRectangle( Clipping, r, c, c, c, c, true );
    }  

    /* draw the center point of the beam */
    c = color( BeamColor.red, BeamColor.green, BeamColor.blue, 0x80 );
    r = rect( aX    , y1    , aX + 1, y2 + 1 );
    Canvas.FillRectangle( Clipping, r, c, c, c, c, true );

  }

  // The 'UpdateSlot' is responsible to draw the next sequence of data samples. The \
  // number of samples depends on the current settings of 'RefreshRate' and the 'MillisecPerDiv'.
  $rect <510,440,710,480>
  slot UpdateSlot
  {
    /* Remark: In order to simplifiy this demo application, we assume, that for 
       each horizontal position one samples is read from the underlying measurement 
       equipment and that each sample is in the range from -100 ... + 100 */

    var int32 noOfSamples;
    var int32 x;
    var int32 y1;
    var int32 y2;
    var rect r;
    var rect invalidateRect;
    var int32 wiper;

    /* just to be sure... */
    if ( Canvas == null )
      return;

    /* calculate size of screen wiper */
    wiper = ScreenWiper * Bounds.w / 100;

    /* first we have to decide, whether a full screen update is necessary or just
       part of the screen are redrawn */

    if ( RefreshRate / Speed >= 10 )
    {
      /* we have to make a full screen update */
      noOfSamples = Bounds.w;

      /* clear complete area */
      r = rect( 0, 0, Bounds.w, Bounds.h );
      Canvas.FillRectangle( r, r, #000000FF, #000000FF, #000000FF, #000000FF, false );

      /* complete area needs to be updated at the end */
      invalidateRect = rect( 0, 0, Bounds.w, Bounds.h );
    }
    else
    {
      /* only part of the screen will be drawn */
      noOfSamples = ( Bounds.w * RefreshRate ) / ( Speed * 10 );

      /* here we make a small simplification: at least one sample is drawn */
      if ( noOfSamples == 0 )
        noOfSamples = 1;

      /* get current beam position */
      x = BeamPosition.x + 1;

      /* clear area right of the beam position */
      r = rect( x + 2, 0, x + 5 + noOfSamples, Bounds.h );
      Canvas.FillRectangle( r, r, #000000FF, #000000FF, #000000FF, #000000FF, false );

      /* calculate the necessary update area */
      invalidateRect = rect( x - 4, 0, x + 4 + noOfSamples, Bounds.h );

      /* check for wrap around */
      if ( x + noOfSamples > Bounds.w )
      {
        /* clear area at the left side */
        r = rect( 0, 0, x + 5 + noOfSamples - Bounds.w, Bounds.h );
        Canvas.FillRectangle( r, r, #000000FF, #000000FF, #000000FF, #000000FF, false );
        
        /* due to wrap around complete area needs to be updated at the end */
        invalidateRect = rect( 0, 0, Bounds.w, Bounds.h );
      }

      /* blend area right of the beam position if screen wiper is active */
      if ( wiper > 0 )
      {
        /* blend area right of the beam position */
        r = rect( x + 2 + noOfSamples, 0, x + wiper + noOfSamples, Bounds.h );
        Canvas.FillRectangle( r, r, #0000001F, #0000001F, #0000001F, #0000001F, true );
      
        /* calculate the necessary update area */
        invalidateRect = rect( x - 4, 0, x + 4 + wiper + noOfSamples, Bounds.h );

        /* check for wrap around of wiper */
        if ( x + wiper + noOfSamples > Bounds.w )
        {
          /* blend area at the left side */
          r = rect( 0, 0, x + wiper + noOfSamples - Bounds.w, Bounds.h );
          Canvas.FillRectangle( r, r, #0000001F, #0000001F, #0000001F, #0000001F, true );
      
          /* due to wrap around complete area needs to be updated at the end */
          invalidateRect = rect( 0, 0, Bounds.w, Bounds.h );
        }
      }
    }

    /* now, all samples are drawn... */
    while ( noOfSamples > 0 )
    {
      /* get next beam position */
      x = BeamPosition.x + 1;
      if ( x >= Bounds.w )
        x = 0;
      
      /* calculate start and end value in vertical direction */
      y1 = BeamPosition.y;
      y2 = Bounds.h / 2 - GetSampleData( x ) * Bounds.h / 200;

      /* adjust start position for one pixel to avoid double drawing */
      if ( y2 > y1 )
        y1 = y1 + 1;
      if ( y2 < y1 )
        y1 = y1 - 1;

      /* draw the beam from the last sample value to the new sample value */
      DrawBeamLine( x, y1, y2 );

      /* store the current beam position */
      BeamPosition.x = x;
      BeamPosition.y = y2;

      /* next one... */
      noOfSamples = noOfSamples - 1;
    }

    /* finally, we set the calculated area as invalid area of the image object
       to force the redrawing */
    InvalidateArea( invalidateRect );

  }

  // This function returns the data of the given index from an simulated measurement \
  // equipment. 
  $rect <240,330,440,370>
  method int32 GetSampleData( arg int32 aIndex )
  {
    var int32 value;

    if ( DataProvider == null )
      value = aIndex % 100 - 50;

    else
      value = DataProvider.GetSampleData( aIndex );
      
    /* modify the value with the gain */
    value = value * Gain / 100;

    if ( value < -100 )
      value = -100;
    if ( value > 100 )
      value = 100;

    return value;

  }

  $rect <830,210,1030,250>
  slot DrawGraph
  {
    //var int32 randomNumber = math_rand( 0, 10 );

    if (DataProvider == null)
        return;
    var float currVal = float(DataProvider.GetSampleData( index ));
    // compute max
    if (currVal > max) {
        max = currVal;
        MaxValue.String = string(max, 0, 1);
    }
    // get mean
    if (index!=0) {
        sum = sum + currVal;
        MeanValue.String = string(sum / float(index),0,1);
    }
    CurrValue.String = string(currVal, 0, 1); // 2 decimal values
    var float vOffset = Graph.Bounds.h / Graph.PixelPerUnit.y;
    var float hOffset = Graph.Bounds.w / Graph.PixelPerUnit.x;
    var float vScalingFactor = float(Graph.PixelPerUnit.y) / float(Graph.Bounds.h);
    CoordList.AddCoord( index,  vOffset/2.0 - vScalingFactor * float(currVal));
    Graph.Coordinates = CoordList;
    // to do loop graph and reset statistics
    if(float(index)>=hOffset) {
        index= 0;
        CoordList.ClearList();
        sum = 0;
    }
    index = index + 1;
    // Invoke UpdateViewState
    this.InvalidateViewState();
  }

  $rect <830,250,1030,290>
  var int32 index = 0;

  $rect <20,90,200,130>
  object Charts::CoordList CoordList
  {
    preset MaxNoOfItems = 1000;
  }

  $rect <1030,170,1230,210>
  var float mean;

  $rect <1030,210,1230,250>
  var float max = -10000.0;

  $rect <1040,260,1240,300>
  var float sum = -10000.0;
}

$rect <580,210,780,250>
$output false
class MenubarSTM32 : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,480,68>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,0,70,70>;
    preset Label = "Menu";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <65,0,135,70>;
    preset Label = "Settings";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <135,0,205,70>;
    preset Label = "Exp. pause";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <205,0,270,70>;
    preset Label = "Insp. Pause";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <270,0,340,70>;
    preset Label = "Freeze";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton5
  {
    preset Bounds = <340,0,410,70>;
    preset Label = "Set Assisted";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton6
  {
    preset Bounds = <415,0,485,70>;
    preset Label = "Caption";
    preset Appearance = WidgetSet::PushButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton7
  {
    preset Bounds = <410,0,480,70>;
    preset Label = "Set auto";
    preset Appearance = WidgetSet::PushButton_Small;
  }
}

// This is a font resource.
$rect <790,170,990,210>
$output false
resource Resources::Font FontXXS
{
  attr fontname FontName = Arial;
  attr fontheight Height = 6;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

// Win32 Res(800x640)
note group Note4
{
  attr Bounds = <0,90,520,260>;
}

// STM32 Res(480x272)
note group Note5
{
  attr Bounds = <520,90,1040,260>;
}

// Simple data storage class to provide dummy data - in a real oscilloscope an interface \
// to provide real measured data should replace this data source.
$rect <10,310,280,350>
$output false
class DataSource
{
  // This is an array.
  $rect <20,70,220,110>
  array int32 DummyData[ 100 ] =
  (
    Default[0] = 0;
    Default[1] = 0;
    Default[2] = 0;
    Default[3] = 0;
    Default[4] = 0;
    Default[5] = 0;
    Default[6] = 0;
    Default[7] = 0;
    Default[8] = 0;
    Default[9] = 0;
    Default[10] = 0;
    Default[11] = 0;
    Default[12] = 0;
    Default[13] = 0;
    Default[14] = 0;
    Default[15] = 0;
    Default[16] = 0;
    Default[17] = 0;
    Default[18] = 0;
    Default[19] = 0;
    Default[20] = 0;
    Default[21] = 0;
    Default[22] = 0;
    Default[23] = 0;
    Default[24] = 0;
    Default[25] = 0;
    Default[26] = 0;
    Default[27] = 0;
    Default[28] = 0;
    Default[29] = 0;
    Default[30] = 0;
    Default[31] = 0;
    Default[32] = 0;
    Default[33] = 0;
    Default[34] = 0;
    Default[35] = 0;
    Default[36] = 0;
    Default[37] = 0;
    Default[38] = 0;
    Default[39] = 0;
    Default[40] = 0;
    Default[41] = 0;
    Default[42] = 0;
    Default[43] = 0;
    Default[44] = 0;
    Default[45] = 0;
    Default[46] = 0;
    Default[47] = 0;
    Default[48] = 0;
    Default[49] = 0;
    Default[50] = 0;
    Default[51] = 0;
    Default[52] = 0;
    Default[53] = 0;
    Default[54] = 0;
    Default[55] = 0;
    Default[56] = 0;
    Default[57] = 0;
    Default[58] = 0;
    Default[59] = 0;
    Default[60] = 0;
    Default[61] = 0;
    Default[62] = 0;
    Default[63] = 0;
    Default[64] = 0;
    Default[65] = 0;
    Default[66] = 0;
    Default[67] = 0;
    Default[68] = 0;
    Default[69] = 0;
    Default[70] = 0;
    Default[71] = 0;
    Default[72] = 0;
    Default[73] = 0;
    Default[74] = 0;
    Default[75] = 0;
    Default[76] = 0;
    Default[77] = 0;
    Default[78] = 0;
    Default[79] = 0;
    Default[80] = 0;
    Default[81] = 0;
    Default[82] = 0;
    Default[83] = 0;
    Default[84] = 0;
    Default[85] = 0;
    Default[86] = 0;
    Default[87] = 0;
    Default[88] = 0;
    Default[89] = 0;
    Default[90] = 0;
    Default[91] = 0;
    Default[92] = 0;
    Default[93] = 0;
    Default[94] = 0;
    Default[95] = 0;
    Default[96] = 0;
    Default[97] = 0;
    Default[98] = 0;
    Default[99] = 0;
  );

  // This function returns the data of the given index from an simulated measurement \
  // equipment. 
  $rect <20,20,220,60>
  method int32 GetSampleData( arg int32 aIndex )
  {
    var int32 i = ( aIndex * Speed / 100 ) % DummyData.size;

    return DummyData[ i ];

  }

  // The property 'Speed' stores the speed of the associated beam in milliseconds \
  // per division. Depending on the speed, the necessary number of samples have to \
  // be provided.
  $rect <220,20,420,60>
  property int32 Speed = 1000;
}

$rect <240,410,510,450>
$output false
class DataSource2 : Application::DataSource
{
  $rect <20,70,220,110>
  inherited array DummyData[] =
  (
    Default[1] = 0;
    Default[2] = 0;
    Default[3] = 0;
    Default[4] = 0;
    Default[5] = 0;
    Default[6] = 0;
    Default[7] = 0;
    Default[8] = 0;
    Default[9] = 0;
    Default[10] = 0;
    Default[11] = -1;
    Default[12] = -2;
    Default[13] = -3;
    Default[14] = -5;
    Default[15] = -6;
    Default[16] = -7;
    Default[17] = -9;
    Default[18] = -13;
    Default[19] = -14;
    Default[20] = -15;
    Default[21] = -15;
    Default[22] = -14;
    Default[23] = -13;
    Default[24] = -10;
    Default[25] = -6;
    Default[26] = 0;
    Default[27] = 9;
    Default[28] = 19;
    Default[29] = 29;
    Default[30] = 42;
    Default[31] = 50;
    Default[32] = 54;
    Default[33] = 56;
    Default[34] = 56;
    Default[35] = 53;
    Default[36] = 46;
    Default[37] = 31;
    Default[38] = 16;
    Default[39] = 6;
    Default[40] = -1;
    Default[41] = -9;
    Default[42] = -16;
    Default[43] = -20;
    Default[44] = -23;
    Default[45] = -24;
    Default[46] = -24;
    Default[47] = -23;
    Default[48] = -19;
    Default[49] = -15;
    Default[50] = -11;
    Default[51] = -6;
    Default[52] = -2;
    Default[53] = 1;
    Default[54] = 5;
    Default[55] = 6;
    Default[56] = 5;
    Default[57] = 3;
    Default[58] = 1;
    Default[59] = -1;
    Default[60] = -4;
    Default[61] = -6;
    Default[62] = -7;
    Default[63] = -7;
    Default[64] = -4;
    Default[65] = -2;
    Default[66] = -1;
    Default[67] = -1;
    Default[68] = 0;
    Default[69] = 0;
    Default[70] = 0;
    Default[71] = 0;
    Default[72] = 0;
    Default[73] = 0;
    Default[74] = 0;
    Default[75] = 0;
    Default[76] = 0;
    Default[77] = 0;
    Default[78] = 0;
    Default[79] = 0;
    Default[80] = 0;
    Default[81] = 0;
    Default[82] = 0;
    Default[83] = 0;
    Default[84] = 0;
    Default[85] = 0;
    Default[86] = 0;
    Default[87] = 0;
    Default[88] = 0;
    Default[89] = 0;
    Default[90] = 0;
    Default[91] = 0;
    Default[92] = 0;
    Default[93] = 0;
    Default[94] = 0;
    Default[95] = 0;
    Default[96] = 0;
    Default[97] = 0;
    Default[98] = 0;
    Default[99] = 0;
  );

  $rect <20,20,220,60>
  inherited method GetSampleData()
  {
    var int32 i = ( aIndex * Speed / 200 ) % DummyData.size;
    return DummyData[ i ];

  }
}

$rect <240,360,510,400>
$output false
class DataSource1 : Application::DataSource
{
  $rect <20,70,220,110>
  inherited array DummyData[] =
  (
    Default[1] = 0;
    Default[2] = 2;
    Default[3] = 0;
    Default[4] = -2;
    Default[5] = 0;
    Default[6] = 4;
    Default[7] = 0;
    Default[8] = -4;
    Default[9] = 0;
    Default[10] = 6;
    Default[11] = 0;
    Default[12] = -6;
    Default[13] = 0;
    Default[14] = 8;
    Default[15] = 0;
    Default[16] = -8;
    Default[17] = 0;
    Default[18] = 10;
    Default[19] = 0;
    Default[20] = -10;
    Default[21] = 0;
    Default[22] = 12;
    Default[23] = 0;
    Default[24] = -12;
    Default[25] = 0;
    Default[26] = 14;
    Default[27] = 0;
    Default[28] = -14;
    Default[29] = 0;
    Default[30] = 16;
    Default[31] = 0;
    Default[32] = -16;
    Default[33] = 0;
    Default[34] = 18;
    Default[35] = 0;
    Default[36] = -18;
    Default[37] = 0;
    Default[38] = 20;
    Default[39] = 0;
    Default[40] = -20;
    Default[41] = 0;
    Default[42] = 22;
    Default[43] = 0;
    Default[44] = -22;
    Default[45] = 0;
    Default[46] = 24;
    Default[47] = 0;
    Default[48] = -24;
    Default[49] = 0;
    Default[50] = 26;
    Default[51] = 0;
    Default[52] = -26;
    Default[53] = 0;
    Default[54] = 28;
    Default[55] = 0;
    Default[56] = -28;
    Default[57] = 0;
    Default[58] = 30;
    Default[59] = 0;
    Default[60] = -30;
    Default[61] = 0;
    Default[62] = 32;
    Default[63] = 0;
    Default[64] = -32;
    Default[65] = 0;
    Default[66] = 34;
    Default[67] = 0;
    Default[68] = -34;
    Default[69] = 0;
    Default[70] = 36;
    Default[71] = 0;
    Default[72] = -36;
    Default[73] = 0;
    Default[74] = 38;
    Default[75] = 0;
    Default[76] = -38;
    Default[77] = 0;
    Default[78] = 40;
    Default[79] = 0;
    Default[80] = -40;
    Default[81] = 0;
    Default[82] = 42;
    Default[83] = 0;
    Default[84] = -42;
    Default[85] = 0;
    Default[86] = 44;
    Default[87] = 0;
    Default[88] = -44;
    Default[89] = 0;
    Default[90] = 46;
    Default[91] = 0;
    Default[92] = -46;
    Default[93] = 0;
    Default[94] = 48;
    Default[95] = 0;
    Default[96] = -48;
    Default[97] = 0;
    Default[98] = 0;
    Default[99] = 0;
  );

  $rect <20,20,220,60>
  inherited method GetSampleData()
  {
    var int32 i = ( aIndex * Speed / 1000 ) % DummyData.size;
    return DummyData[ i ];

  }
}

$rect <240,310,510,350>
$output false
class DataSource0 : Application::DataSource
{
  $rect <20,70,220,110>
  inherited array DummyData[] =
  (
    Default[1] = 0;
    Default[2] = 2;
    Default[3] = 0;
    Default[4] = -2;
    Default[5] = 0;
    Default[6] = 4;
    Default[7] = 0;
    Default[8] = -4;
    Default[9] = 0;
    Default[10] = 6;
    Default[11] = 0;
    Default[12] = -6;
    Default[13] = 0;
    Default[14] = 8;
    Default[15] = 0;
    Default[16] = -8;
    Default[17] = 0;
    Default[18] = 10;
    Default[19] = 0;
    Default[20] = -10;
    Default[21] = 0;
    Default[22] = 12;
    Default[23] = 0;
    Default[24] = -12;
    Default[25] = 0;
    Default[26] = 14;
    Default[27] = 0;
    Default[28] = -14;
    Default[29] = 0;
    Default[30] = 16;
    Default[31] = 0;
    Default[32] = -16;
    Default[33] = 0;
    Default[34] = 18;
    Default[35] = 0;
    Default[36] = -18;
    Default[37] = 0;
    Default[38] = 20;
    Default[39] = 0;
    Default[40] = -20;
    Default[41] = 0;
    Default[42] = 22;
    Default[43] = 0;
    Default[44] = -22;
    Default[45] = 0;
    Default[46] = 24;
    Default[47] = 0;
    Default[48] = -24;
    Default[49] = 0;
    Default[50] = 26;
    Default[51] = 0;
    Default[52] = -26;
    Default[53] = 0;
    Default[54] = 28;
    Default[55] = 0;
    Default[56] = -28;
    Default[57] = 0;
    Default[58] = 30;
    Default[59] = 0;
    Default[60] = -30;
    Default[61] = 0;
    Default[62] = 32;
    Default[63] = 0;
    Default[64] = -32;
    Default[65] = 0;
    Default[66] = 34;
    Default[67] = 0;
    Default[68] = -34;
    Default[69] = 0;
    Default[70] = 36;
    Default[71] = 0;
    Default[72] = -36;
    Default[73] = 0;
    Default[74] = 38;
    Default[75] = 0;
    Default[76] = -38;
    Default[77] = 0;
    Default[78] = 40;
    Default[79] = 0;
    Default[80] = -40;
    Default[81] = 0;
    Default[82] = 42;
    Default[83] = 0;
    Default[84] = -42;
    Default[85] = 0;
    Default[86] = 44;
    Default[87] = 0;
    Default[88] = -44;
    Default[89] = 0;
    Default[90] = 46;
    Default[91] = 0;
    Default[92] = -46;
    Default[93] = 0;
    Default[94] = 48;
    Default[95] = 0;
    Default[96] = -48;
    Default[97] = 0;
    Default[98] = 0;
    Default[99] = 0;
  );

  $rect <20,20,220,60>
  inherited method GetSampleData()
  {
    var int32 i = ( aIndex * Speed / 1000 ) % DummyData.size;
    return DummyData[ i ];

  }
}

// Data source
note group Note6
{
  attr Bounds = <0,270,520,490>;
}
